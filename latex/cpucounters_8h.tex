\section{cpucounters.\+h File Reference}
\label{cpucounters_8h}\index{cpucounters.\+h@{cpucounters.\+h}}


Main C\+P\+U counters header.  


{\ttfamily \#include \char`\"{}types.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}msr.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pci.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}client\+\_\+bw.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}width\+\_\+extender.\+h\char`\"{}}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$limits$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$semaphore.\+h$>$}\\*
{\ttfamily \#include $<$sys/types.\+h$>$}\\*
{\ttfamily \#include $<$sys/stat.\+h$>$}\\*
{\ttfamily \#include $<$fcntl.\+h$>$}\\*
{\ttfamily \#include $<$unistd.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Topology\+Entry}
\item 
class {\bf Server\+P\+C\+I\+C\+F\+G\+Uncore}
\begin{DoxyCompactList}\small\item\em Object to access uncore counters in a socket/processor with microarchitecture codename Sandy\+Bridge-\/\+E\+P (Jaketown) or Ivytown-\/\+E\+P or Ivytown-\/\+E\+X. \end{DoxyCompactList}\item 
class {\bf P\+C\+Ie\+Counter\+State}
\item 
class {\bf P\+C\+M}
\begin{DoxyCompactList}\small\item\em C\+P\+U Performance Monitor. \end{DoxyCompactList}\item 
struct {\bf P\+C\+M\+::\+Custom\+Core\+Event\+Description}
\begin{DoxyCompactList}\small\item\em Custom Core event description. \end{DoxyCompactList}\item 
struct {\bf P\+C\+M\+::\+Extended\+Custom\+Core\+Event\+Description}
\begin{DoxyCompactList}\small\item\em Extended custom core event description. \end{DoxyCompactList}\item 
class {\bf Basic\+Counter\+State}
\begin{DoxyCompactList}\small\item\em Basic core counter state. \end{DoxyCompactList}\item 
class {\bf Uncore\+Counter\+State}
\begin{DoxyCompactList}\small\item\em Basic uncore counter state. \end{DoxyCompactList}\item 
class {\bf Server\+Uncore\+Power\+State}
\begin{DoxyCompactList}\small\item\em Server uncore power counter state. \end{DoxyCompactList}\item 
class {\bf Core\+Counter\+State}
\begin{DoxyCompactList}\small\item\em (Logical) core-\/wide counter state \end{DoxyCompactList}\item 
class {\bf Socket\+Counter\+State}
\begin{DoxyCompactList}\small\item\em Socket-\/wide counter state. \end{DoxyCompactList}\item 
class {\bf System\+Counter\+State}
\begin{DoxyCompactList}\small\item\em System-\/wide counter state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries I\+N\+T\+E\+L\+\_\+\+P\+C\+M\+\_\+\+V\+E\+R\+S\+I\+O\+N}~\char`\"{}V2.\+8 (2014-\/12-\/18 12\+:52\+:39 +0100 I\+D=ba39a89)\char`\"{}\label{cpucounters_8h_aedd2ffc654feec5f46ee4138213b8321}

\item 
\#define {\bfseries I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I}\label{cpucounters_8h_ae4b6fb4f70f9e5a7fe1603982546945e}

\item 
\#define {\bfseries N\+O\+M\+I\+N\+M\+A\+X}\label{cpucounters_8h_a9f918755b601cf4bffca775992e6fb90}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Q\+P\+I\+Clocks} (uint32 port, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns Q\+P\+I L\+L clock ticks. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\int32 {\bfseries get\+Thermal\+Headroom} (const Counter\+State\+Type \&, const Counter\+State\+Type \&after)\label{cpucounters_8h_a4e29bb6fe37d6d31e4132eb1d32b1451}

\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Q\+P\+I\+L0p\+Tx\+Cycles} (uint32 port, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns the number of Q\+P\+I cycles in power saving half-\/lane mode. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Q\+P\+I\+L1\+Cycles} (uint32 port, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns the number of Q\+P\+I cycles in power saving shutdown mode. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles} (uint32 port, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns the ratio of Q\+P\+I cycles in power saving half-\/lane mode. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Normalized\+Q\+P\+I\+L1\+Cycles} (uint32 port, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns the ratio of Q\+P\+I cycles in power saving shutdown mode. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+D\+R\+A\+M\+Clocks} (uint32 channel, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns D\+R\+A\+M clock ticks. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+M\+C\+Counter} (uint32 channel, uint32 counter, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Direct read of memory controller P\+M\+U counter (counter meaning depends on the programming\+: power/performance/etc) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+P\+C\+U\+Counter} (uint32 counter, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Direct read of power control unit P\+M\+U counter (counter meaning depends on the programming\+: power/performance/etc) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+P\+C\+U\+Clocks} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns clock ticks of power control unit. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Consumed\+Energy} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns energy consumed by processor, exclusing D\+R\+A\+M (measured in internal units) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+D\+R\+A\+M\+Consumed\+Energy} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns energy consumed by D\+R\+A\+M (measured in internal units) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Consumed\+Joules} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns Joules consumed by processor (excluding D\+R\+A\+M) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+D\+R\+A\+M\+Consumed\+Joules} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns Joules consumed by D\+R\+A\+M. \end{DoxyCompactList}\item 
I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf System\+Counter\+State} {\bf get\+System\+Counter\+State} ()
\begin{DoxyCompactList}\small\item\em Reads the counter state of the system. \end{DoxyCompactList}\item 
I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf Socket\+Counter\+State} {\bf get\+Socket\+Counter\+State} (uint32 socket)
\begin{DoxyCompactList}\small\item\em Reads the counter state of a socket. \end{DoxyCompactList}\item 
I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf Core\+Counter\+State} {\bf get\+Core\+Counter\+State} (uint32 core)
\begin{DoxyCompactList}\small\item\em Reads the counter state of a (logical) core. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+I\+P\+C} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average number of retired instructions per core cycle (I\+P\+C) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Instructions\+Retired} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes the number of retired instructions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Exec\+Usage} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average number of retired instructions per time intervall. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Instructions\+Retired} (const Counter\+State\+Type \&now)
\begin{DoxyCompactList}\small\item\em Computes the number of retired instructions. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Cycles} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes the number core clock cycles when signal on a specific core is running (not halted) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Ref\+Cycles} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes the number of reference clock cycles while clock signal on the core is running. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Cycles} (const Counter\+State\+Type \&now)
\begin{DoxyCompactList}\small\item\em Computes the number executed core clock cycles. \end{DoxyCompactList}\item 
double {\bf get\+Core\+I\+P\+C} (const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Computes average number of retired instructions per core cycle for the entire system combining instruction counts from logical cores to corresponding physical cores. \end{DoxyCompactList}\item 
double {\bf get\+Total\+Exec\+Usage} (const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Computes average number of retired instructions per time intervall for the entire system combining instruction counts from logical cores to corresponding physical cores. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Average\+Frequency} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average core frequency also taking Intel Turbo Boost technology into account. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Active\+Average\+Frequency} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average core frequency when not in powersaving C0-\/state (also taking Intel Turbo Boost technology into account) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Relative\+Frequency} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average core frequency also taking Intel Turbo Boost technology into account. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Active\+Relative\+Frequency} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes average core frequency when not in powersaving C0-\/state (also taking Intel Turbo Boost technology into account) \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Estimates how many core cycles were potentially lost due to L3 cache misses. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Estimates how many core cycles were potentially lost due to missing L2 cache but still hitting L3 cache. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+L2\+Cache\+Hit\+Ratio} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes L2 cache hit ratio. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+L3\+Cache\+Hit\+Ratio} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes L3 cache hit ratio. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L3\+Cache\+Misses} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of L3 cache misses. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L2\+Cache\+Misses} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of L2 cache misses. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L2\+Cache\+Hits} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of L2 cache hits. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L3\+Cache\+Occupancy} (const Counter\+State\+Type \&now)
\begin{DoxyCompactList}\small\item\em Computes L3 Cache Occupancy. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L3\+Cache\+Hits\+No\+Snoop} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of L3 cache hits where no snooping in sibling L2 caches had to be done. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L3\+Cache\+Hits\+Snoop} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of L3 cache hits where snooping in sibling L2 caches had to be done. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+L3\+Cache\+Hits} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes total number of L3 cache hits. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Invariant\+T\+S\+C} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of invariant time stamp counter ticks. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Core\+C\+State\+Residency} (int state, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes residency in the core C-\/state. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\double {\bf get\+Package\+C\+State\+Residency} (int state, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes residency in the package C-\/state. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Bytes\+Read\+From\+M\+C} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of bytes read from D\+R\+A\+M memory controllers. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Bytes\+Written\+To\+M\+C} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of bytes written to D\+R\+A\+M memory controllers. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+I\+O\+Request\+Bytes\+From\+M\+C} (const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Computes number of bytes of read/write requests from all I\+O sources. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Counter\+State\+Type $>$ }\\uint64 {\bf get\+Number\+Of\+Custom\+Events} (int32 event\+Counter\+Nr, const Counter\+State\+Type \&before, const Counter\+State\+Type \&after)
\begin{DoxyCompactList}\small\item\em Returns the number of occured custom core events. \end{DoxyCompactList}\item 
uint64 {\bf get\+Incoming\+Q\+P\+I\+Link\+Bytes} (uint32 socket\+Nr, uint32 link\+Nr, const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get estimation of Q\+P\+I data traffic per incoming Q\+P\+I link. \end{DoxyCompactList}\item 
double {\bf get\+Incoming\+Q\+P\+I\+Link\+Utilization} (uint32 socket\+Nr, uint32 link\+Nr, const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get data utilization of incoming Q\+P\+I link (0..1) \end{DoxyCompactList}\item 
double {\bf get\+Outgoing\+Q\+P\+I\+Link\+Utilization} (uint32 socket\+Nr, uint32 link\+Nr, const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get utilization of outgoing Q\+P\+I link (0..1) \end{DoxyCompactList}\item 
uint64 {\bf get\+Outgoing\+Q\+P\+I\+Link\+Bytes} (uint32 socket\+Nr, uint32 link\+Nr, const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get estimation of Q\+P\+I (data+nondata) traffic per outgoing Q\+P\+I link. \end{DoxyCompactList}\item 
uint64 {\bf get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes} (const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get estimation of total Q\+P\+I data traffic. \end{DoxyCompactList}\item 
uint64 {\bf get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes} (const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get estimation of total Q\+P\+I data+nondata traffic. \end{DoxyCompactList}\item 
uint64 {\bf get\+Incoming\+Q\+P\+I\+Link\+Bytes} (uint32 socket\+Nr, uint32 link\+Nr, const {\bf System\+Counter\+State} \&now)
\begin{DoxyCompactList}\small\item\em Return current value of the counter of Q\+P\+I data traffic per incoming Q\+P\+I link. \end{DoxyCompactList}\item 
uint64 {\bf get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes} (uint32 socket\+Nr, const {\bf System\+Counter\+State} \&now)
\begin{DoxyCompactList}\small\item\em Get estimation of total Q\+P\+I data traffic for this socket. \end{DoxyCompactList}\item 
uint64 {\bf get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes} (const {\bf System\+Counter\+State} \&now)
\begin{DoxyCompactList}\small\item\em Get estimation of Socket Q\+P\+I data traffic. \end{DoxyCompactList}\item 
double {\bf get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio} (const {\bf System\+Counter\+State} \&before, const {\bf System\+Counter\+State} \&after)
\begin{DoxyCompactList}\small\item\em Get Q\+P\+I data to Memory Controller traffic ratio. \end{DoxyCompactList}\item 
uint64 {\bf get\+Number\+Of\+Events} ({\bf P\+C\+Ie\+Counter\+State} before, {\bf P\+C\+Ie\+Counter\+State} after)
\begin{DoxyCompactList}\small\item\em Returns the raw count of P\+C\+Ie events. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Main C\+P\+U counters header. 

Include this header file if you want to access C\+P\+U counters (core and uncore -\/ including memory controller chips and Q\+P\+I) 

\subsection{Function Documentation}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Active\+Average\+Frequency@{get\+Active\+Average\+Frequency}}
\index{get\+Active\+Average\+Frequency@{get\+Active\+Average\+Frequency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Active\+Average\+Frequency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Active\+Average\+Frequency (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a963d78be64ccddb4f7686405ef4df9c1}


Computes average core frequency when not in powersaving C0-\/state (also taking Intel Turbo Boost technology into account) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
frequency in Hz 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Nominal\+Frequency().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Active\+Relative\+Frequency@{get\+Active\+Relative\+Frequency}}
\index{get\+Active\+Relative\+Frequency@{get\+Active\+Relative\+Frequency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Active\+Relative\+Frequency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Active\+Relative\+Frequency (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a9a351e598b8af26131611ff37b592633}


Computes average core frequency when not in powersaving C0-\/state (also taking Intel Turbo Boost technology into account) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Fraction of nominal frequency (if $>$1.\+0 then Turbo was working during the measurement) 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}}
\index{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a1f83dc2b6cd3a1efcd850003e26c6404}


Get estimation of total Q\+P\+I data traffic. 

Returns an estimation of number of data bytes transferred to all sockets over all Intel(r) Quick Path Interconnect links


\begin{DoxyParams}{Parameters}
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


References get\+Incoming\+Q\+P\+I\+Link\+Bytes(), P\+C\+M\+::get\+Instance(), P\+C\+M\+::get\+Num\+Sockets(), and P\+C\+M\+::get\+Q\+P\+I\+Links\+Per\+Socket().



Referenced by get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}}
\index{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{now}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_ad21f46c2ea28e3ca5c074fc7749b7395}


Get estimation of Socket Q\+P\+I data traffic. 

Returns an estimation of number of data bytes transferred to all sockets over all Intel(r) Quick Path Interconnect links


\begin{DoxyParams}{Parameters}
{\em now} & System C\+P\+U counter state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), P\+C\+M\+::get\+Num\+Sockets(), and get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes@{get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes}}
\index{get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes@{get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a0b914c4bffa783271c276b29be582370}


Get estimation of total Q\+P\+I data+nondata traffic. 

Returns an estimation of number of data and non-\/data bytes transferred from all sockets over all Intel(r) Quick Path Interconnect links


\begin{DoxyParams}{Parameters}
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), P\+C\+M\+::get\+Num\+Sockets(), get\+Outgoing\+Q\+P\+I\+Link\+Bytes(), and P\+C\+M\+::get\+Q\+P\+I\+Links\+Per\+Socket().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Average\+Frequency@{get\+Average\+Frequency}}
\index{get\+Average\+Frequency@{get\+Average\+Frequency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Average\+Frequency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Average\+Frequency (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_aa398facfd523b7dcdbf827a74970a88c}


Computes average core frequency also taking Intel Turbo Boost technology into account. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
frequency in Hz 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Nominal\+Frequency().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Bytes\+Read\+From\+M\+C@{get\+Bytes\+Read\+From\+M\+C}}
\index{get\+Bytes\+Read\+From\+M\+C@{get\+Bytes\+Read\+From\+M\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Bytes\+Read\+From\+M\+C}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Bytes\+Read\+From\+M\+C (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a0f28a32a3edeaecd916ba097aee99d7f}


Computes number of bytes read from D\+R\+A\+M memory controllers. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


Referenced by get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Bytes\+Written\+To\+M\+C@{get\+Bytes\+Written\+To\+M\+C}}
\index{get\+Bytes\+Written\+To\+M\+C@{get\+Bytes\+Written\+To\+M\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Bytes\+Written\+To\+M\+C}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Bytes\+Written\+To\+M\+C (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a24fce7df2ee7140db18ecfcd74fe63d1}


Computes number of bytes written to D\+R\+A\+M memory controllers. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


Referenced by get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Consumed\+Energy@{get\+Consumed\+Energy}}
\index{get\+Consumed\+Energy@{get\+Consumed\+Energy}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Consumed\+Energy}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Consumed\+Energy (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a054b949f09283093e1923affa4e58ae8}


Returns energy consumed by processor, exclusing D\+R\+A\+M (measured in internal units) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+Consumed\+Joules().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Consumed\+Joules@{get\+Consumed\+Joules}}
\index{get\+Consumed\+Joules@{get\+Consumed\+Joules}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Consumed\+Joules}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Consumed\+Joules (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_af8f7dab111f6b8cbcfa0c1b81e1860fb}


Returns Joules consumed by processor (excluding D\+R\+A\+M) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


References get\+Consumed\+Energy(), P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Joules\+Per\+Energy\+Unit().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Core\+Counter\+State@{get\+Core\+Counter\+State}}
\index{get\+Core\+Counter\+State@{get\+Core\+Counter\+State}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Core\+Counter\+State}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf Core\+Counter\+State} get\+Core\+Counter\+State (
\begin{DoxyParamCaption}
\item[{uint32}]{core}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a3641dfa6466049072b8937ee64b03738}


Reads the counter state of a (logical) core. 

Helper function. Uses \doxyref{P\+C\+M}{p.}{classPCM} object to access counters.


\begin{DoxyParams}{Parameters}
{\em core} & core id \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
State of counters in the core 
\end{DoxyReturn}


References P\+C\+M\+::get\+Core\+Counter\+State(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Core\+C\+State\+Residency@{get\+Core\+C\+State\+Residency}}
\index{get\+Core\+C\+State\+Residency@{get\+Core\+C\+State\+Residency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Core\+C\+State\+Residency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Core\+C\+State\+Residency (
\begin{DoxyParamCaption}
\item[{int}]{state, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a98aa8d4eb21e8a992fc181d65018e5ce}


Computes residency in the core C-\/state. 


\begin{DoxyParams}{Parameters}
{\em state} & C-\/state \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
residence ratio (0..1)\+: 0 -\/ 0\%, 1.\+0 -\/ 100\% 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), get\+Invariant\+T\+S\+C(), get\+Ref\+Cycles(), and P\+C\+M\+::is\+Core\+C\+State\+Residency\+Supported().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Core\+I\+P\+C@{get\+Core\+I\+P\+C}}
\index{get\+Core\+I\+P\+C@{get\+Core\+I\+P\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Core\+I\+P\+C}]{\setlength{\rightskip}{0pt plus 5cm}double get\+Core\+I\+P\+C (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_abaca7147e6334e13bbbc718e4a537568}


Computes average number of retired instructions per core cycle for the entire system combining instruction counts from logical cores to corresponding physical cores. 

Use this metric to evaluate I\+P\+C improvement between S\+M\+T(\+Hyperthreading) on and S\+M\+T off.


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+P\+C 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), get\+I\+P\+C(), P\+C\+M\+::get\+Num\+Cores(), P\+C\+M\+::get\+Num\+Online\+Cores(), and P\+C\+M\+::get\+Threads\+Per\+Core().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Cycles@{get\+Cycles}}
\index{get\+Cycles@{get\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Cycles (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a5a3275c4f489a475f1658f4546567af4}


Computes the number core clock cycles when signal on a specific core is running (not halted) 

Returns number of used cycles (halted cyles are not counted). The counter does not advance in the following conditions\+:
\begin{DoxyItemize}
\item an A\+C\+P\+I C-\/state is other than C0 for normal operation
\item H\+L\+T
\item S\+T\+P\+C\+L\+K+ pin is asserted
\item being throttled by T\+M1
\item during the frequency switching phase of a performance state transition
\end{DoxyItemize}

The performance counter for this event counts across performance state transitions using different core clock frequencies


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number core clock cycles 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Cycles@{get\+Cycles}}
\index{get\+Cycles@{get\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Cycles (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{now}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_adc17d576ecaf02cf98cebc86329bf2a1}


Computes the number executed core clock cycles. 

Returns number of used cycles (halted cyles are not counted).


\begin{DoxyParams}{Parameters}
{\em now} & Current C\+P\+U counter state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number core clock cycles 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses@{get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses}}
\index{get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses@{get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Cycles\+Lost\+Due\+L2\+Cache\+Misses (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_ac26765efe8a4c7341f40c8ab8bdb9af6}


Estimates how many core cycles were potentially lost due to missing L2 cache but still hitting L3 cache. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 

Currently not supported on Intel(\+R) Atom(tm) processor 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
ratio that is usually beetween 0 and 1 ; in some cases could be $>$1.\+0 due to a lower access latency estimation 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses@{get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses}}
\index{get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses@{get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Cycles\+Lost\+Due\+L3\+Cache\+Misses (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a89d4cef9c83db7e76be6a0a2e7351e2e}


Estimates how many core cycles were potentially lost due to L3 cache misses. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
ratio that is usually beetween 0 and 1 ; in some cases could be $>$1.\+0 due to a lower memory latency estimation 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+D\+R\+A\+M\+Clocks@{get\+D\+R\+A\+M\+Clocks}}
\index{get\+D\+R\+A\+M\+Clocks@{get\+D\+R\+A\+M\+Clocks}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+D\+R\+A\+M\+Clocks}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+D\+R\+A\+M\+Clocks (
\begin{DoxyParamCaption}
\item[{uint32}]{channel, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_aeb1baf7feb391c0512dc378a9fd66a17}


Returns D\+R\+A\+M clock ticks. 


\begin{DoxyParams}{Parameters}
{\em channel} & D\+R\+A\+M channel number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+D\+R\+A\+M\+Consumed\+Energy@{get\+D\+R\+A\+M\+Consumed\+Energy}}
\index{get\+D\+R\+A\+M\+Consumed\+Energy@{get\+D\+R\+A\+M\+Consumed\+Energy}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+D\+R\+A\+M\+Consumed\+Energy}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+D\+R\+A\+M\+Consumed\+Energy (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a71af0766460ef7dd3d138ec0d0924eda}


Returns energy consumed by D\+R\+A\+M (measured in internal units) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+D\+R\+A\+M\+Consumed\+Joules().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+D\+R\+A\+M\+Consumed\+Joules@{get\+D\+R\+A\+M\+Consumed\+Joules}}
\index{get\+D\+R\+A\+M\+Consumed\+Joules@{get\+D\+R\+A\+M\+Consumed\+Joules}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+D\+R\+A\+M\+Consumed\+Joules}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+D\+R\+A\+M\+Consumed\+Joules (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_ab6f97a3386ac2d35dfd61148acde0a53}


Returns Joules consumed by D\+R\+A\+M. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


References P\+C\+M\+::get\+C\+P\+U\+Model(), get\+D\+R\+A\+M\+Consumed\+Energy(), P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Joules\+Per\+Energy\+Unit().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Exec\+Usage@{get\+Exec\+Usage}}
\index{get\+Exec\+Usage@{get\+Exec\+Usage}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Exec\+Usage}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Exec\+Usage (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a159a6896f5ef3626b88cdd27a3c15ac0}


Computes average number of retired instructions per time intervall. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
usage 
\end{DoxyReturn}


Referenced by get\+Total\+Exec\+Usage().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Incoming\+Q\+P\+I\+Link\+Bytes}}
\index{get\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Incoming\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Incoming\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+Incoming\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{uint32}]{link\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_aca1b1d8ba1679c4a0c394c2647428fd3}


Get estimation of Q\+P\+I data traffic per incoming Q\+P\+I link. 

Returns an estimation of number of data bytes transferred to a socket over Intel(r) Quick Path Interconnect


\begin{DoxyParams}{Parameters}
{\em socket\+Nr} & socket identifier \\
\hline
{\em link\+Nr} & link\+Nr \\
\hline
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


Referenced by get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes(), get\+Incoming\+Q\+P\+I\+Link\+Utilization(), and get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Incoming\+Q\+P\+I\+Link\+Bytes}}
\index{get\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Incoming\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Incoming\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+Incoming\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{uint32}]{link\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{now}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a42d6a119a26ea41c40d5585356d832ca}


Return current value of the counter of Q\+P\+I data traffic per incoming Q\+P\+I link. 

Returns the number of incoming data bytes to a socket over Intel(r) Quick Path Interconnect


\begin{DoxyParams}{Parameters}
{\em socket\+Nr} & socket identifier \\
\hline
{\em link\+Nr} & link\+Nr \\
\hline
{\em now} & Current System C\+P\+U counter state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Incoming\+Q\+P\+I\+Link\+Utilization@{get\+Incoming\+Q\+P\+I\+Link\+Utilization}}
\index{get\+Incoming\+Q\+P\+I\+Link\+Utilization@{get\+Incoming\+Q\+P\+I\+Link\+Utilization}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Incoming\+Q\+P\+I\+Link\+Utilization}]{\setlength{\rightskip}{0pt plus 5cm}double get\+Incoming\+Q\+P\+I\+Link\+Utilization (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{uint32}]{link\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a0ba3a5b71b7dd6b84c345f8cbc795b1c}


Get data utilization of incoming Q\+P\+I link (0..1) 

Returns an estimation of utilization of Q\+P\+I link by data traffic transferred to a socket over Intel(r) Quick Path Interconnect


\begin{DoxyParams}{Parameters}
{\em socket\+Nr} & socket identifier \\
\hline
{\em link\+Nr} & link\+Nr \\
\hline
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
utilization (0..1) 
\end{DoxyReturn}


References get\+Incoming\+Q\+P\+I\+Link\+Bytes(), P\+C\+M\+::get\+Instance(), get\+Invariant\+T\+S\+C(), P\+C\+M\+::get\+Nominal\+Frequency(), P\+C\+M\+::get\+Num\+Cores(), and P\+C\+M\+::get\+Q\+P\+I\+Link\+Speed().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Instructions\+Retired@{get\+Instructions\+Retired}}
\index{get\+Instructions\+Retired@{get\+Instructions\+Retired}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Instructions\+Retired}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Instructions\+Retired (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_af124718a7620c7bbca81232c2149f771}


Computes the number of retired instructions. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of retired instructions 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Instructions\+Retired@{get\+Instructions\+Retired}}
\index{get\+Instructions\+Retired@{get\+Instructions\+Retired}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Instructions\+Retired}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Instructions\+Retired (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{now}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_afced47e4bb3712da79dc64cb16ac335a}


Computes the number of retired instructions. 


\begin{DoxyParams}{Parameters}
{\em now} & Current C\+P\+U counter state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of retired instructions 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Invariant\+T\+S\+C@{get\+Invariant\+T\+S\+C}}
\index{get\+Invariant\+T\+S\+C@{get\+Invariant\+T\+S\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Invariant\+T\+S\+C}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Invariant\+T\+S\+C (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a45cf07a8d3ce2c48968842554a3854f9}


Computes number of invariant time stamp counter ticks. 

This counter counts irrespectively of C-\/, P-\/ or T-\/states


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of time stamp counter ticks 
\end{DoxyReturn}


Referenced by get\+Core\+C\+State\+Residency(), get\+Incoming\+Q\+P\+I\+Link\+Utilization(), get\+Outgoing\+Q\+P\+I\+Link\+Bytes(), get\+Outgoing\+Q\+P\+I\+Link\+Utilization(), get\+Package\+C\+State\+Residency(), and P\+C\+M\+::get\+Tick\+Count().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+I\+O\+Request\+Bytes\+From\+M\+C@{get\+I\+O\+Request\+Bytes\+From\+M\+C}}
\index{get\+I\+O\+Request\+Bytes\+From\+M\+C@{get\+I\+O\+Request\+Bytes\+From\+M\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+I\+O\+Request\+Bytes\+From\+M\+C}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+I\+O\+Request\+Bytes\+From\+M\+C (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a7e5434dba3a810501f289329e52b889d}


Computes number of bytes of read/write requests from all I\+O sources. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+I\+P\+C@{get\+I\+P\+C}}
\index{get\+I\+P\+C@{get\+I\+P\+C}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+I\+P\+C}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+I\+P\+C (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a7b0019d24a77dc05b7e47cb98192fd22}


Computes average number of retired instructions per core cycle (I\+P\+C) 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
I\+P\+C 
\end{DoxyReturn}


Referenced by get\+Core\+I\+P\+C().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L2\+Cache\+Hit\+Ratio@{get\+L2\+Cache\+Hit\+Ratio}}
\index{get\+L2\+Cache\+Hit\+Ratio@{get\+L2\+Cache\+Hit\+Ratio}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L2\+Cache\+Hit\+Ratio}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+L2\+Cache\+Hit\+Ratio (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a5922acedeec3c1cc67d20670f8ef0518}


Computes L2 cache hit ratio. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
value between 0 and 1 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L2\+Cache\+Hits@{get\+L2\+Cache\+Hits}}
\index{get\+L2\+Cache\+Hits@{get\+L2\+Cache\+Hits}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L2\+Cache\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L2\+Cache\+Hits (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a459367d7877d09594c2ecd85e04cae61}


Computes number of L2 cache hits. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of hits 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L2\+Cache\+Misses@{get\+L2\+Cache\+Misses}}
\index{get\+L2\+Cache\+Misses@{get\+L2\+Cache\+Misses}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L2\+Cache\+Misses}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L2\+Cache\+Misses (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a291eeab262fdb93de08cdfdf50dbad58}


Computes number of L2 cache misses. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of misses 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Hit\+Ratio@{get\+L3\+Cache\+Hit\+Ratio}}
\index{get\+L3\+Cache\+Hit\+Ratio@{get\+L3\+Cache\+Hit\+Ratio}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Hit\+Ratio}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+L3\+Cache\+Hit\+Ratio (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a7b03f0cd02862716d717e897032b7885}


Computes L3 cache hit ratio. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
value between 0 and 1 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Hits@{get\+L3\+Cache\+Hits}}
\index{get\+L3\+Cache\+Hits@{get\+L3\+Cache\+Hits}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Hits}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L3\+Cache\+Hits (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a7ba16714ef7ed547ad8648cb5b9e52f6}


Computes total number of L3 cache hits. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of hits 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), P\+C\+M\+::get\+Instance(), get\+L3\+Cache\+Hits\+No\+Snoop(), and get\+L3\+Cache\+Hits\+Snoop().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Hits\+No\+Snoop@{get\+L3\+Cache\+Hits\+No\+Snoop}}
\index{get\+L3\+Cache\+Hits\+No\+Snoop@{get\+L3\+Cache\+Hits\+No\+Snoop}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Hits\+No\+Snoop}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L3\+Cache\+Hits\+No\+Snoop (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_ace0e3ffc23c20d0eda7663cb7e4899a2}


Computes number of L3 cache hits where no snooping in sibling L2 caches had to be done. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of hits 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().



Referenced by get\+L3\+Cache\+Hits().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Hits\+Snoop@{get\+L3\+Cache\+Hits\+Snoop}}
\index{get\+L3\+Cache\+Hits\+Snoop@{get\+L3\+Cache\+Hits\+Snoop}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Hits\+Snoop}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L3\+Cache\+Hits\+Snoop (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a4b1050ca9ccdd66661df556bab70fd0f}


Computes number of L3 cache hits where snooping in sibling L2 caches had to be done. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of hits 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().



Referenced by get\+L3\+Cache\+Hits().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Misses@{get\+L3\+Cache\+Misses}}
\index{get\+L3\+Cache\+Misses@{get\+L3\+Cache\+Misses}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Misses}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L3\+Cache\+Misses (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a94118e70266db2ed7fc6b8b7b4e2c343}


Computes number of L3 cache misses. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Works only in the D\+E\+F\+A\+U\+L\+T\+\_\+\+E\+V\+E\+N\+T\+S programming mode (see program() method) 
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
number of misses 
\end{DoxyReturn}


References P\+C\+M\+::get\+C\+P\+U\+Model(), and P\+C\+M\+::get\+Instance().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+L3\+Cache\+Occupancy@{get\+L3\+Cache\+Occupancy}}
\index{get\+L3\+Cache\+Occupancy@{get\+L3\+Cache\+Occupancy}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+L3\+Cache\+Occupancy}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+L3\+Cache\+Occupancy (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{now}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a185f850a9a753d9cf4deb8299261fd4c}


Computes L3 Cache Occupancy. 

\index{cpucounters.\+h@{cpucounters.\+h}!get\+M\+C\+Counter@{get\+M\+C\+Counter}}
\index{get\+M\+C\+Counter@{get\+M\+C\+Counter}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+M\+C\+Counter}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+M\+C\+Counter (
\begin{DoxyParamCaption}
\item[{uint32}]{channel, }
\item[{uint32}]{counter, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_aed082cc97dbad35e1633823e582afa0f}


Direct read of memory controller P\+M\+U counter (counter meaning depends on the programming\+: power/performance/etc) 


\begin{DoxyParams}{Parameters}
{\em counter} & counter number \\
\hline
{\em channel} & channel number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles@{get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles}}
\index{get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles@{get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles (
\begin{DoxyParamCaption}
\item[{uint32}]{port, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_aa5a7caff83891aafc6e9eb20501170cc}


Returns the ratio of Q\+P\+I cycles in power saving half-\/lane mode. 


\begin{DoxyParams}{Parameters}
{\em port} & Q\+P\+I port number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0..1 -\/ ratio of Q\+P\+I cycles in power saving half-\/lane mode 
\end{DoxyReturn}


References get\+Q\+P\+I\+Clocks(), and get\+Q\+P\+I\+L0p\+Tx\+Cycles().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Normalized\+Q\+P\+I\+L1\+Cycles@{get\+Normalized\+Q\+P\+I\+L1\+Cycles}}
\index{get\+Normalized\+Q\+P\+I\+L1\+Cycles@{get\+Normalized\+Q\+P\+I\+L1\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Normalized\+Q\+P\+I\+L1\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Normalized\+Q\+P\+I\+L1\+Cycles (
\begin{DoxyParamCaption}
\item[{uint32}]{port, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a0ea54e2a783ce71cef06350aed099104}


Returns the ratio of Q\+P\+I cycles in power saving shutdown mode. 


\begin{DoxyParams}{Parameters}
{\em port} & Q\+P\+I port number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0..1 -\/ ratio of Q\+P\+I cycles in power saving shutdown mode 
\end{DoxyReturn}


References get\+Q\+P\+I\+Clocks(), and get\+Q\+P\+I\+L1\+Cycles().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Number\+Of\+Custom\+Events@{get\+Number\+Of\+Custom\+Events}}
\index{get\+Number\+Of\+Custom\+Events@{get\+Number\+Of\+Custom\+Events}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Number\+Of\+Custom\+Events}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Number\+Of\+Custom\+Events (
\begin{DoxyParamCaption}
\item[{int32}]{event\+Counter\+Nr, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_abaa9d828b52f41866bf7dc8ff491a62e}


Returns the number of occured custom core events. 

Read number of events programmed with the {\ttfamily C\+U\+S\+T\+O\+M\+\_\+\+C\+O\+R\+E\+\_\+\+E\+V\+E\+N\+T\+S} 


\begin{DoxyParams}{Parameters}
{\em event\+Counter\+Nr} & Event/counter number (value from 0 to 3) \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Number\+Of\+Events@{get\+Number\+Of\+Events}}
\index{get\+Number\+Of\+Events@{get\+Number\+Of\+Events}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Number\+Of\+Events}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+Number\+Of\+Events (
\begin{DoxyParamCaption}
\item[{{\bf P\+C\+Ie\+Counter\+State}}]{before, }
\item[{{\bf P\+C\+Ie\+Counter\+State}}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a3dfbc795387d801541439b6c035c7b8c}


Returns the raw count of P\+C\+Ie events. 


\begin{DoxyParams}{Parameters}
{\em before} & P\+C\+Ie counter state before the experiment \\
\hline
{\em after} & P\+C\+Ie counter state after the experiment \\
\hline
\end{DoxyParams}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Outgoing\+Q\+P\+I\+Link\+Bytes@{get\+Outgoing\+Q\+P\+I\+Link\+Bytes}}
\index{get\+Outgoing\+Q\+P\+I\+Link\+Bytes@{get\+Outgoing\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Outgoing\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+Outgoing\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{uint32}]{link\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a6bdb34d102d7353421bd878da7b9ef23}


Get estimation of Q\+P\+I (data+nondata) traffic per outgoing Q\+P\+I link. 

Returns an estimation of number of data bytes transferred from a socket over Intel(r) Quick Path Interconnect


\begin{DoxyParams}{Parameters}
{\em socket\+Nr} & socket identifier \\
\hline
{\em link\+Nr} & link\+Nr \\
\hline
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), get\+Invariant\+T\+S\+C(), P\+C\+M\+::get\+Nominal\+Frequency(), P\+C\+M\+::get\+Num\+Cores(), get\+Outgoing\+Q\+P\+I\+Link\+Utilization(), and P\+C\+M\+::get\+Q\+P\+I\+Link\+Speed().



Referenced by get\+All\+Outgoing\+Q\+P\+I\+Link\+Bytes().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Outgoing\+Q\+P\+I\+Link\+Utilization@{get\+Outgoing\+Q\+P\+I\+Link\+Utilization}}
\index{get\+Outgoing\+Q\+P\+I\+Link\+Utilization@{get\+Outgoing\+Q\+P\+I\+Link\+Utilization}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Outgoing\+Q\+P\+I\+Link\+Utilization}]{\setlength{\rightskip}{0pt plus 5cm}double get\+Outgoing\+Q\+P\+I\+Link\+Utilization (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{uint32}]{link\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_ac7b1863133a9a711117fcb8b68d2d773}


Get utilization of outgoing Q\+P\+I link (0..1) 

Returns an estimation of utilization of Q\+P\+I link by (data+nondata) traffic transferred from a socket over Intel(r) Quick Path Interconnect


\begin{DoxyParams}{Parameters}
{\em socket\+Nr} & socket identifier \\
\hline
{\em link\+Nr} & link\+Nr \\
\hline
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
utilization (0..1) 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), get\+Invariant\+T\+S\+C(), P\+C\+M\+::get\+Nominal\+Frequency(), P\+C\+M\+::get\+Num\+Cores(), and P\+C\+M\+::get\+Q\+P\+I\+Link\+Speed().



Referenced by get\+Outgoing\+Q\+P\+I\+Link\+Bytes().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Package\+C\+State\+Residency@{get\+Package\+C\+State\+Residency}}
\index{get\+Package\+C\+State\+Residency@{get\+Package\+C\+State\+Residency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Package\+C\+State\+Residency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Package\+C\+State\+Residency (
\begin{DoxyParamCaption}
\item[{int}]{state, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a5e34f7b0326dda86b54fcb7bb84a0b38}


Computes residency in the package C-\/state. 


\begin{DoxyParams}{Parameters}
{\em state} & C-\/state \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
residence ratio (0..1)\+: 0 -\/ 0\%, 1.\+0 -\/ 100\% 
\end{DoxyReturn}


References get\+Invariant\+T\+S\+C().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+P\+C\+U\+Clocks@{get\+P\+C\+U\+Clocks}}
\index{get\+P\+C\+U\+Clocks@{get\+P\+C\+U\+Clocks}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+P\+C\+U\+Clocks}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+P\+C\+U\+Clocks (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_acd430f703c67fc7dc0829d624ba657af}


Returns clock ticks of power control unit. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


References get\+P\+C\+U\+Counter().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+P\+C\+U\+Counter@{get\+P\+C\+U\+Counter}}
\index{get\+P\+C\+U\+Counter@{get\+P\+C\+U\+Counter}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+P\+C\+U\+Counter}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+P\+C\+U\+Counter (
\begin{DoxyParamCaption}
\item[{uint32}]{counter, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a3c424ad42d2439410d6ffc371335573d}


Direct read of power control unit P\+M\+U counter (counter meaning depends on the programming\+: power/performance/etc) 


\begin{DoxyParams}{Parameters}
{\em counter} & counter number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+P\+C\+U\+Clocks().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Q\+P\+I\+Clocks@{get\+Q\+P\+I\+Clocks}}
\index{get\+Q\+P\+I\+Clocks@{get\+Q\+P\+I\+Clocks}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Q\+P\+I\+Clocks}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Q\+P\+I\+Clocks (
\begin{DoxyParamCaption}
\item[{uint32}]{port, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_af7d9ba0936d7c305d0cc6c2db296a336}


Returns Q\+P\+I L\+L clock ticks. 


\begin{DoxyParams}{Parameters}
{\em port} & Q\+P\+I port number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles(), and get\+Normalized\+Q\+P\+I\+L1\+Cycles().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Q\+P\+I\+L0p\+Tx\+Cycles@{get\+Q\+P\+I\+L0p\+Tx\+Cycles}}
\index{get\+Q\+P\+I\+L0p\+Tx\+Cycles@{get\+Q\+P\+I\+L0p\+Tx\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Q\+P\+I\+L0p\+Tx\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Q\+P\+I\+L0p\+Tx\+Cycles (
\begin{DoxyParamCaption}
\item[{uint32}]{port, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_acdac5d9d7a5a6496d90b0681badc26b3}


Returns the number of Q\+P\+I cycles in power saving half-\/lane mode. 


\begin{DoxyParams}{Parameters}
{\em port} & Q\+P\+I port number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+Normalized\+Q\+P\+I\+L0p\+Tx\+Cycles().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Q\+P\+I\+L1\+Cycles@{get\+Q\+P\+I\+L1\+Cycles}}
\index{get\+Q\+P\+I\+L1\+Cycles@{get\+Q\+P\+I\+L1\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Q\+P\+I\+L1\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Q\+P\+I\+L1\+Cycles (
\begin{DoxyParamCaption}
\item[{uint32}]{port, }
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a580ae4e465d0f8dd93935ad7af28c095}


Returns the number of Q\+P\+I cycles in power saving shutdown mode. 


\begin{DoxyParams}{Parameters}
{\em port} & Q\+P\+I port number \\
\hline
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}


Referenced by get\+Normalized\+Q\+P\+I\+L1\+Cycles().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio@{get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio}}
\index{get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio@{get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio}]{\setlength{\rightskip}{0pt plus 5cm}double get\+Q\+P\+Ito\+M\+C\+Traffic\+Ratio (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a17823150d51bdebdd203dfa00b0a5f49}


Get Q\+P\+I data to Memory Controller traffic ratio. 

Ideally for N\+U\+M\+A-\/optmized programs the ratio should be close to 0.


\begin{DoxyParams}{Parameters}
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Ratio 
\end{DoxyReturn}


References get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes(), get\+Bytes\+Read\+From\+M\+C(), and get\+Bytes\+Written\+To\+M\+C().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Ref\+Cycles@{get\+Ref\+Cycles}}
\index{get\+Ref\+Cycles@{get\+Ref\+Cycles}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Ref\+Cycles}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ uint64 get\+Ref\+Cycles (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_aaa3691b803702deec828d0d8d8a8f326}


Computes the number of reference clock cycles while clock signal on the core is running. 

The reference clock operates at a fixed frequency, irrespective of core frequency changes due to performance state transitions. See Intel(r) Software Developer\textquotesingle{}s Manual for more details


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number core clock cycles 
\end{DoxyReturn}


Referenced by get\+Core\+C\+State\+Residency().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Relative\+Frequency@{get\+Relative\+Frequency}}
\index{get\+Relative\+Frequency@{get\+Relative\+Frequency}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Relative\+Frequency}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Counter\+State\+Type $>$ double get\+Relative\+Frequency (
\begin{DoxyParamCaption}
\item[{const Counter\+State\+Type \&}]{before, }
\item[{const Counter\+State\+Type \&}]{after}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a806e72bc51f05acc4af0667ca3334242}


Computes average core frequency also taking Intel Turbo Boost technology into account. 


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Fraction of nominal frequency 
\end{DoxyReturn}
\index{cpucounters.\+h@{cpucounters.\+h}!get\+Socket\+Counter\+State@{get\+Socket\+Counter\+State}}
\index{get\+Socket\+Counter\+State@{get\+Socket\+Counter\+State}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Socket\+Counter\+State}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf Socket\+Counter\+State} get\+Socket\+Counter\+State (
\begin{DoxyParamCaption}
\item[{uint32}]{socket}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_a63896fb0783b57857e3ede0f24083a2a}


Reads the counter state of a socket. 

Helper function. Uses \doxyref{P\+C\+M}{p.}{classPCM} object to access counters.


\begin{DoxyParams}{Parameters}
{\em socket} & socket id \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
State of counters in the socket 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Socket\+Counter\+State().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes}}
\index{get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes@{get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes}]{\setlength{\rightskip}{0pt plus 5cm}uint64 get\+Socket\+Incoming\+Q\+P\+I\+Link\+Bytes (
\begin{DoxyParamCaption}
\item[{uint32}]{socket\+Nr, }
\item[{const {\bf System\+Counter\+State} \&}]{now}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_ae6e948c5ad7859e3760336aa02f466bd}


Get estimation of total Q\+P\+I data traffic for this socket. 

Returns an estimation of number of bytes transferred to this sockets over all Intel(r) Quick Path Interconnect links on this socket


\begin{DoxyParams}{Parameters}
{\em before} & System C\+P\+U counter state before the experiment \\
\hline
{\em after} & System C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes 
\end{DoxyReturn}


References get\+Incoming\+Q\+P\+I\+Link\+Bytes(), P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+Q\+P\+I\+Links\+Per\+Socket().



Referenced by get\+All\+Incoming\+Q\+P\+I\+Link\+Bytes().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+System\+Counter\+State@{get\+System\+Counter\+State}}
\index{get\+System\+Counter\+State@{get\+System\+Counter\+State}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+System\+Counter\+State}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+T\+E\+L\+P\+C\+M\+\_\+\+A\+P\+I {\bf System\+Counter\+State} get\+System\+Counter\+State (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{cpucounters_8h_ac225ab9b4b77afb098ddefd13025d14c}


Reads the counter state of the system. 

Helper function. Uses \doxyref{P\+C\+M}{p.}{classPCM} object to access counters.

System consists of several sockets (C\+P\+Us). Socket has a C\+P\+U in it. Socket (C\+P\+U) consists of several (logical) cores.

\begin{DoxyReturn}{Returns}
State of counters in the entire system 
\end{DoxyReturn}


References P\+C\+M\+::get\+Instance(), and P\+C\+M\+::get\+System\+Counter\+State().

\index{cpucounters.\+h@{cpucounters.\+h}!get\+Total\+Exec\+Usage@{get\+Total\+Exec\+Usage}}
\index{get\+Total\+Exec\+Usage@{get\+Total\+Exec\+Usage}!cpucounters.\+h@{cpucounters.\+h}}
\subsubsection[{get\+Total\+Exec\+Usage}]{\setlength{\rightskip}{0pt plus 5cm}double get\+Total\+Exec\+Usage (
\begin{DoxyParamCaption}
\item[{const {\bf System\+Counter\+State} \&}]{before, }
\item[{const {\bf System\+Counter\+State} \&}]{after}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{cpucounters_8h_a546944a165ea621d77a524b15ccd6cf1}


Computes average number of retired instructions per time intervall for the entire system combining instruction counts from logical cores to corresponding physical cores. 

Use this metric to evaluate cores utilization improvement between S\+M\+T(\+Hyperthreading) on and S\+M\+T off.


\begin{DoxyParams}{Parameters}
{\em before} & C\+P\+U counter state before the experiment \\
\hline
{\em after} & C\+P\+U counter state after the experiment \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
usage 
\end{DoxyReturn}


References get\+Exec\+Usage(), P\+C\+M\+::get\+Instance(), P\+C\+M\+::get\+Num\+Cores(), P\+C\+M\+::get\+Num\+Online\+Cores(), and P\+C\+M\+::get\+Threads\+Per\+Core().

